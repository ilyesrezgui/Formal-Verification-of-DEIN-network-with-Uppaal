<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>
    const int N=3;
    typedef int[0,N-1] id_wd;
    
    double lamda=35; //lamda en cm
    double energy_lost;


    double nbBit = 4; // Nombre de bits pour un message

    broadcast chan HAP2WD;

    chan Send_Data[N],Data_Sent, WD2HAP_REQ[N];
    
    double globalE_Sent;
  </declaration>
	<template>
		<name x="5" y="5">HAP</name>
		<declaration>    int totSendIt;
    const int N=3;
    typedef int[0,N-1] id_wd;
    id_wd id_sender;
    id_wd id_sending_wd;
    int E_sent =400;
    int Nb_data_sent[N]={0,0,0};
    clock time_to_return; // time needed to return to the idel state after data reception
    int period_for_recieving= 10;
 
void incrementAtId(int&amp; Nb_data_sent[N], int id) {
        Nb_data_sent[id]=Nb_data_sent[id]+1; 
    }








    
   







</declaration>
		<location id="id0" x="-93" y="-25">
			<name x="-110" y="-8">Idle</name>
		</location>
		<location id="id1" x="442" y="-34">
			<name x="468" y="-43">SignalTransmission</name>
		</location>
		<location id="id2" x="-433" y="-212">
			<name x="-459" y="-255">DataReception</name>
			<label kind="invariant" x="-552" y="-272">time_to_return&lt;=period_for_recieving</label>
		</location>
		<init ref="id0"/>
		<transition id="id3">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="assignment" x="-408" y="-25">time_to_return=0</label>
			<nail x="-433" y="-34"/>
			<nail x="-289" y="-34"/>
		</transition>
		<transition id="id4">
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="select" x="-263" y="-238">id:id_wd</label>
			<label kind="synchronisation" x="-263" y="-221">Send_Data[id]?</label>
			<label kind="assignment" x="-263" y="-204">id_sending_wd=id,
incrementAtId(Nb_data_sent,id),
time_to_return=0</label>
		</transition>
		<transition id="id5">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="136" y="-68">HAP2WD!</label>
		</transition>
		<transition id="id6">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="select" x="263" y="-272">id:id_wd</label>
			<label kind="synchronisation" x="263" y="-246">WD2HAP_REQ[id]?</label>
			<label kind="assignment" x="263" y="-221">id_sender=id,
totSendIt=totSendIt+1,
globalE_Sent=E_sent</label>
			<nail x="136" y="-212"/>
		</transition>
	</template>
	<template>
		<name>WD</name>
		<parameter>const id_wd id, double EpckPerBit ,double Sensing_Value  ,double distance, double maxCapacity,double E_Current_Quantity,double E_Current_Percentage </parameter>
		<declaration>     // double EpckPerBit = 1;  // Énergie consommée et nécessaire pour envoyer des données de WD à HAP.
     // double E_Current_Percentage;  // Représente le pourcentage, calculé plus tard.
      double decodingPercentage = 0.4;
      double E_received;
      double E_Harvested; // we have
      double E_Decoded; 
      
      double T_E_Decoded;
      
      double E_Loss_Distance;
      double T_E_Loss_Distance;
      
      double E_Cap_Surplus;
      double T_E_Cap_Surplus=0;
      
      double consumed_E_QuantityPerMessage;
      double T_E_consumed_for_Messages=0;
      
      double E_Loss_Below_Sensing;
      double T_E_Loss_Below_Sensing;

      const double M_PI       = 3.141592653589793115997963468544185161590576171875; // to define pi , took the value from uppaal offical documentation https://docs.uppaal.org/language-reference/expressions/
      const double SPEED_OF_LIGHT = 299792458;

// this function calulates lambda value represnting the wavelength
double calculateWavelength(double frequency) {
    return SPEED_OF_LIGHT / frequency;
}

// this will calculate the path loss L
double calculateFSPL(double distanceMeters, double frequencyHz) {
    // Calculate the FSPL in dB
    double fspl = 20 * log10(distanceMeters) + 20 * log10(frequencyHz) - 147.55;

    return fspl;
}

double calculateReceivedPower(double PT, double GT, double GR, double frequency_in_Hz, double d) {
    double lambda = calculateWavelength(frequency_in_Hz);
    double L_dB = calculateFSPL(d, frequency_in_Hz);
    double L = pow(10, L_dB / 10.0); // Convert FSPL from dB to linear scale

    // Calculate the received power using the Friis transmission equation
    double numerator = PT * GT * GR * pow(lambda, 2);
    double denominator = pow(4 * M_PI * d, 2) * L;
    double PR = numerator / denominator;
    return PR;
}



// y heya E_Current_Quantity
// x heya E_Harvested
double verif_capacity(double x,double y){
// we want to analyse energy lost with repsect to distance  
double k=x;
k=calculateReceivedPower(x,3.8,3.8,915e3,distance);
if (k+y&gt;maxCapacity){
        energy_lost= energy_lost+(k+y-maxCapacity);
        T_E_Loss_Distance=T_E_Loss_Distance +(k+y-maxCapacity);
        return maxCapacity;  
    }
    else {
        return k+y;}
}

      
    
    
    
    </declaration>
		<location id="id7" x="-41" y="-26">
			<name x="-58" y="-8">Idle</name>
		</location>
		<location id="id8" x="811" y="-26">
			<name x="828" y="-34">SignalReception</name>
		</location>
		<location id="id9" x="-564" y="-220">
			<name x="-675" y="-254">DataTransmission</name>
		</location>
		<init ref="id7"/>
		<transition id="id10">
			<source ref="id9"/>
			<target ref="id7"/>
			<nail x="-629" y="8"/>
		</transition>
		<transition id="id11">
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="guard" x="-595" y="-374">E_Current_Quantity &gt;= EpckPerBit * nbBit</label>
			<label kind="synchronisation" x="-595" y="-391">Send_Data[id]!</label>
			<label kind="assignment" x="-595" y="-348">consumed_E_QuantityPerMessage = EpckPerBit * nbBit,
T_E_consumed_for_Messages=T_E_consumed_for_Messages+consumed_E_QuantityPerMessage,
E_Current_Quantity = E_Current_Quantity - consumed_E_QuantityPerMessage,
E_Current_Percentage = (E_Current_Quantity * 100) / maxCapacity</label>
		</transition>
		<transition id="id12">
			<source ref="id7"/>
			<target ref="id7"/>
			<label kind="guard" x="-756" y="76">globalE_Sent/distance&gt;=Sensing_Value</label>
			<label kind="synchronisation" x="-76" y="115">HAP2WD?</label>
			<label kind="assignment" x="-756" y="102">E_received=globalE_Sent/distance,
E_Harvested = E_received,
E_Harvested = (E_Current_Quantity + E_Harvested &gt; maxCapacity) ? (maxCapacity - E_Current_Quantity) : E_Harvested,
E_Loss_Distance=globalE_Sent-E_received,
T_E_Loss_Distance=T_E_Loss_Distance+E_Loss_Distance,
E_Cap_Surplus = (E_Current_Quantity + E_Harvested &gt; maxCapacity) ? (E_Current_Quantity + E_Harvested - maxCapacity) : 0.0,
T_E_Cap_Surplus=T_E_Cap_Surplus+E_Cap_Surplus,
E_Current_Quantity = E_Current_Quantity + E_Harvested ,
E_Current_Percentage = (E_Current_Quantity * 100) / maxCapacity</label>
			<nail x="-109" y="25"/>
			<nail x="-49" y="110"/>
			<nail x="19" y="59"/>
			<nail x="2" y="-1"/>
		</transition>
		<transition id="id13">
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="467" y="-459">globalE_Sent/distance&gt;Sensing_Value</label>
			<label kind="synchronisation" x="467" y="-476">HAP2WD?</label>
			<label kind="assignment" x="467" y="-433">E_received=  globalE_Sent/distance,
E_Harvested = E_received * (1 - decodingPercentage),
E_Decoded = E_received * decodingPercentage,
T_E_Decoded=T_E_Decoded+E_Decoded,


E_Loss_Distance=globalE_Sent-E_received,
T_E_Loss_Distance=T_E_Loss_Distance+E_Loss_Distance,
E_Cap_Surplus = (E_Current_Quantity + E_Harvested &gt; maxCapacity) ? (E_Current_Quantity + E_Harvested - maxCapacity) : 0.0,
T_E_Cap_Surplus=T_E_Cap_Surplus+E_Cap_Surplus,


E_Current_Quantity = E_Current_Quantity + E_Harvested ,
E_Current_Percentage = (E_Current_Quantity * 100) / maxCapacity</label>
			<nail x="273" y="-155"/>
			<nail x="-7" y="-46"/>
		</transition>
		<transition id="id14">
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="guard" x="240" y="11">E_Current_Quantity &gt; EpckPerBit * nbBit</label>
			<label kind="synchronisation" x="241" y="-8">WD2HAP_REQ[id]!</label>
			<label kind="assignment" x="240" y="31">consumed_E_QuantityPerMessage = EpckPerBit * nbBit,
T_E_consumed_for_Messages=T_E_consumed_for_Messages+consumed_E_QuantityPerMessage,
E_Current_Quantity = E_Current_Quantity - consumed_E_QuantityPerMessage</label>
		</transition>
	</template>
	<system>// id_wd, EpckPerBit, Sensing_Value, distance, maxCapacity, E_Current_Quantity, E_Current_Percentage
    WD0 = WD(0, 2000, 4, 20, 550000, 55000, 10);
    WD1 = WD(1, 1000, 2, 20, 80000, 40000, 50);
    WD2 = WD(2, 3000, 3, 35, 200000, 50000, 25);
    system WD1, WD0, WD2, HAP;</system>
	<queries>
		<query>
			<formula/>
			<comment>===== Reachability:</comment>
		</query>
		<query>
			<formula>E&lt;&gt; WD0.SignalReception</formula>
			<comment>The SignalReception state can be reached eventually by WD0.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; WD2.SignalReception</formula>
			<comment>The SignalReception state can be reached eventually by WD2.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; WD1.SignalReception.</formula>
			<comment>The SignalReception state can be reached eventually by WD1.</comment>
		</query>
		<query>
			<formula/>
			<comment>===== Liveness Properties:</comment>
		</query>
		<query>
			<formula>HAP1.SignalTransmission --&gt; WD2.SignalReception or WD1.SignalReception or WD0.SignalReception
      </formula>
			<comment>When a HAP is about transmitting a Signal, one of the WDs should eventually be receiving it.</comment>
		</query>
		<query>
			<formula>WD1.SignalReception --&gt; WD0.Idle and WD2.Idle</formula>
			<comment>One wireless device is receiving a signal at a time. In here WD1 is receiving.</comment>
		</query>
		<query>
			<formula>WD2.SignalReception --&gt; WD0.Idle and WD1.Idle</formula>
			<comment>One wireless device is receiving a signal at a time. In here WD2 is receiving.</comment>
		</query>
		<query>
			<formula/>
			<comment>===== Deadlock checking:</comment>
		</query>
		<query>
			<formula>A[] not deadlock</formula>
			<comment>No deadlocks at all</comment>
		</query>
		<query>
			<formula/>
			<comment>===== Safety Properties:</comment>
		</query>
		<query>
			<formula>A[] WD0.EWD &lt;= WD0.capacity</formula>
			<comment>The energy harvested by a WD should always be lower or equal to the capacity of the WD</comment>
		</query>
		<query>
			<formula>A[] WD1.EWD &lt;= WD1.capacity</formula>
			<comment>The energy harvested by a WD should always be lower or equal to the capacity of the WD</comment>
		</query>
		<query>
			<formula>A[] WD2.EWD &lt;= WD2.capacity</formula>
			<comment>The energy harvested by a WD should always be lower or equal to the capacity of the WD</comment>
		</query>
		<query>
			<formula>E&lt;&gt; not WD2.DataTransmission and (WD0.SignalReception or WD1.SignalReception)</formula>
			<comment>At some point in the future, WD2 is not in the state of DataTransmission, and at the same time, WD0 is in the state of SignalReception or WD1 is in the state of SignalReception.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; not WD0.DataTransmission and (WD1.SignalReception or WD2.SignalReception)</formula>
			<comment/>
		</query>
		<query>
			<formula>E&lt;&gt; not WD1.DataTransmission and (WD0.SignalReception or WD2.SignalReception)</formula>
			<comment/>
		</query>
	</queries>
</nta>
